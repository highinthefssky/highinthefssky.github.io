# Data Model: YouTube Video Hub

**Feature**: YouTube Video Hub with Community Posts  
**Branch**: `001-youtube-video-hub`  
**Date**: 2026-01-18  
**Purpose**: Define entities, relationships, and validation rules for all content

## Entities

### 1. Video

**Description**: Represents a YouTube video synchronized from the channel owner's YouTube channel.

**Location**: `src/content/videos/{videoId}.json` (auto-generated by GitHub Action)

**Attributes**:

| Attribute | Type | Required | Constraints | Example |
|-----------|------|----------|-------------|---------|
| `id` | string | Yes | YouTube Video ID, 11 chars alphanumeric + underscore/hyphen | `dQw4w9WgXcQ` |
| `title` | string | Yes | 1-200 chars, non-empty | `"Rick Astley - Never Gonna Give You Up"` |
| `description` | string | Yes | 1-5000 chars, allows plain text and URLs | `"Official music video for Rick Astley's Never Gonna Give You Up"` |
| `publishedAt` | ISO 8601 date-time | Yes | Valid ISO 8601 format | `"2009-10-25T06:57:33Z"` |
| `thumbnail` | URL string | Yes | HTTPS URL to YouTube thumbnail image | `"https://i.ytimg.com/vi/dQw4w9WgXcQ/maxresdefault.jpg"` |
| `tags` | string[] | Yes | Array of 0-20 tag strings, each 1-50 chars | `["music", "80s", "pop"]` |
| `series` | string | No | Optional video series identifier for grouping | `"Top 10 Songs"` |
| `duration` | number | No | Video length in seconds | `213` |
| `viewCount` | number | No | YouTube view count (informational only) | `1234567890` |

**Validation Rules** (Zod Schema):

```typescript
import { z } from 'astro:content';

export const videoSchema = z.object({
  id: z.string()
    .length(11)
    .regex(/^[a-zA-Z0-9_-]+$/, 'Invalid YouTube Video ID format'),
  
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title cannot exceed 200 characters'),
  
  description: z.string()
    .min(1, 'Description is required')
    .max(5000, 'Description cannot exceed 5000 characters'),
  
  publishedAt: z.string()
    .datetime('Must be valid ISO 8601 datetime'),
  
  thumbnail: z.string()
    .url('Thumbnail must be a valid URL')
    .startsWith('https://', 'Thumbnail must use HTTPS'),
  
  tags: z.array(z.string().min(1).max(50))
    .max(20, 'Cannot have more than 20 tags'),
  
  series: z.string().optional(),
  duration: z.number().int().positive().optional(),
  viewCount: z.number().int().nonnegative().optional(),
});
```

**Relationships**:
- Has many `Tag` entries (through `tags` array)
- References one optional `Series` (through `series` field)
- Belongs to Channel (implicit - all videos from one YouTube channel)

**Access Pattern**:
```typescript
import { getCollection } from 'astro:content';
const allVideos = await getCollection('videos');
const sortedByDate = allVideos.sort((a, b) => 
  new Date(b.data.publishedAt) - new Date(a.data.publishedAt)
);
const latestThree = sortedByDate.slice(0, 3);
```

**State Lifecycle**:
1. Created: YouTube Action fetches video, validates, creates JSON file
2. Published: Committed to repository, included in next build
3. Displayed: Accessible on site (search, carousel, detail page)
4. Archived: Older videos remain accessible but not featured

---

### 2. Community Post

**Description**: Represents a manually-written blog post created by the channel owner to provide context, announcements, or discussion around videos.

**Location**: `src/content/posts/{slug}.md` or `{slug}.mdx` (manually created)

**Attributes**:

| Attribute | Type | Required | Constraints | Example |
|-----------|------|----------|-------------|---------|
| `title` | string | Yes | 1-200 chars, non-empty | `"Behind the Scenes: Recording Studio Setup"` |
| `pubDate` | ISO 8601 date | Yes | Valid ISO 8601 date format | `"2026-01-15"` |
| `author` | string | Yes | 1-100 chars | `"Channel Owner Name"` |
| `description` | string | Yes | 1-500 chars (excerpt for listings) | `"A deep dive into the studio equipment and workflow"` |
| `image` | object | Yes | Featured image with URL and alt text | See below |
| `image.url` | URL string | Yes | HTTPS URL to image | `"/images/studio-setup.jpg"` |
| `image.alt` | string | Yes | 1-200 chars accessibility text | `"Studio setup with microphone and mixer"` |
| `tags` | string[] | Yes | Array of 0-20 tag strings | `["behind-the-scenes", "studio"]` |
| `body` | markdown/MDX | Yes | Post content in Markdown or MDX format | (file content) |

**Frontmatter Format** (YAML):

```yaml
---
title: Behind the Scenes: Recording Studio Setup
pubDate: 2026-01-15
author: Channel Owner Name
description: A deep dive into the studio equipment and workflow
image:
  url: /images/studio-setup.jpg
  alt: Studio setup with microphone and mixer
tags:
  - behind-the-scenes
  - studio
---

## Main Content

Your markdown content here. Supports **bold**, *italic*, links, images, etc.
```

**Validation Rules** (Zod Schema):

```typescript
export const postSchema = z.object({
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title cannot exceed 200 characters'),
  
  pubDate: z.coerce.date()
    .refine(d => d <= new Date(), 'Publication date cannot be in the future'),
  
  author: z.string()
    .min(1, 'Author is required')
    .max(100, 'Author name cannot exceed 100 characters'),
  
  description: z.string()
    .min(1, 'Description is required')
    .max(500, 'Description cannot exceed 500 characters'),
  
  image: z.object({
    url: z.string().url('Image URL must be valid'),
    alt: z.string()
      .min(1, 'Alt text is required')
      .max(200, 'Alt text cannot exceed 200 characters'),
  }),
  
  tags: z.array(z.string().min(1).max(50))
    .max(20, 'Cannot have more than 20 tags'),
});
```

**Relationships**:
- Has many `Tag` entries (through `tags` array)
- Created by Channel Owner (implicit - all posts authored by site owner)
- References Featured Image (one-to-one)

**Access Pattern**:
```typescript
const allPosts = await getCollection('posts');
const sortedByDate = allPosts.sort((a, b) => 
  new Date(b.data.pubDate) - new Date(a.data.pubDate)
);
const singlePost = await getEntryBySlug('posts', 'my-post-slug');
```

**Markdown Support**:
- Headings: `# H1`, `## H2`, etc.
- Formatting: `**bold**`, `*italic*`, `~~strikethrough~~`
- Links: `[text](url)`
- Images: `![alt](url)`
- Lists: `- item`, `1. numbered`
- Blockquotes: `> quote`
- Code blocks: ` ``` ` with language syntax highlight

---

### 3. Content Tag

**Description**: Represents a category, topic, or series label that can be applied to videos and posts for organization and filtering.

**Location**: Derived from all unique `tags` values across Videos and Posts collections (not stored separately)

**Attributes**:

| Attribute | Type | Required | Constraints | Example |
|-----------|------|----------|-------------|---------|
| `name` | string | Yes | 1-50 chars, lowercase with hyphens | `"tutorial"` or `"series-name"` |
| `count` | number | Computed | Number of videos + posts with this tag | `15` |
| `slug` | string | Computed | URL-safe slug derived from name | `"tutorial"` |

**Validation Rules**:

```typescript
export const tagSchema = z.string()
  .min(1, 'Tag cannot be empty')
  .max(50, 'Tag cannot exceed 50 characters')
  .regex(/^[a-z0-9-]+$/, 'Tag must contain only lowercase letters, numbers, and hyphens');
```

**Relationships**:
- Used by many `Video` entries (through Video.tags)
- Used by many `Post` entries (through Post.tags)
- Many-to-many relationship with content

**Access Pattern**:
```typescript
// Extract all unique tags from videos and posts
const allVideos = await getCollection('videos');
const allPosts = await getCollection('posts');
const allTags = new Set([
  ...allVideos.flatMap(v => v.data.tags),
  ...allPosts.flatMap(p => p.data.tags),
]);

// Group content by tag
const getContentByTag = (tag: string) => {
  const videos = allVideos.filter(v => v.data.tags.includes(tag));
  const posts = allPosts.filter(p => p.data.tags.includes(tag));
  return { videos, posts };
};
```

---

## Data Relationships

```
Channel (implicit, all content belongs to one YouTube channel)
├── Video
│   ├── tags: Tag[]
│   └── series: Series (optional)
└── Community Post
    ├── tags: Tag[]
    ├── image: FeaturedImage
    └── author: Author (fixed to channel owner)

Tag (many-to-many)
├── used by Video[]
└── used by Post[]
```

---

## Collection Configuration

**File**: `src/content/config.ts`

```typescript
import { defineCollection, z } from 'astro:content';

const videos = defineCollection({
  type: 'data',
  schema: z.object({
    id: z.string().length(11).regex(/^[a-zA-Z0-9_-]+$/),
    title: z.string().min(1).max(200),
    description: z.string().min(1).max(5000),
    publishedAt: z.string().datetime(),
    thumbnail: z.string().url().startsWith('https://'),
    tags: z.array(z.string().min(1).max(50)).max(20),
    series: z.string().optional(),
    duration: z.number().int().positive().optional(),
    viewCount: z.number().int().nonnegative().optional(),
  }),
});

const posts = defineCollection({
  type: 'content',
  schema: ({ image }) => z.object({
    title: z.string().min(1).max(200),
    pubDate: z.coerce.date().refine(d => d <= new Date()),
    author: z.string().min(1).max(100),
    description: z.string().min(1).max(500),
    image: z.object({
      url: z.string().url(),
      alt: z.string().min(1).max(200),
    }),
    tags: z.array(z.string().min(1).max(50)).max(20),
  }),
});

export const collections = { videos, posts };
```

---

## Data Validation & Constraints

### Build-Time Validation

All data is validated when Astro builds (per Constitution Principle II):

1. **Video JSON files**: Must conform to videoSchema
   - Checked when fetched by GitHub Action (before commit)
   - Re-validated during Astro build
   - Build fails if any video violates schema
   - Error message pinpoints invalid file and field

2. **Post Markdown files**: Must conform to postSchema
   - Checked when Astro processes collection
   - Build fails if frontmatter invalid
   - Error message includes file path and specific validation error

### Data Integrity Rules

- **No duplicates**: Video IDs are unique (enforced by file naming: `{id}.json`)
- **No missing required fields**: Schema validation prevents incomplete data
- **No future-dated posts**: `pubDate` cannot be in future
- **No broken image URLs**: All images must be valid HTTPS URLs
- **No invalid tags**: Tags must match regex pattern

### Edge Case Handling

| Scenario | Handling | Rationale |
|----------|----------|-----------|
| < 3 videos available | Display available videos, hide carousel nav | Still useful; better than error |
| Video with missing thumbnail | Use placeholder image | Still displayable; shows gracefully |
| Post with markdown errors | Build fails with clear error | Forces fix before deployment |
| Tag used only once | Still included in tag list | Allows future content organization |
| Duplicate tags in video | Deduplicated by Set | Normalization |

---

## Implementation Notes

### YouTube Action Data Generation

```javascript
// scripts/fetch-videos.js (GitHub Action)
const video = {
  id: youtubeVideoId,
  title: item.snippet.title,
  description: item.snippet.description,
  publishedAt: item.snippet.publishedAt, // ISO 8601
  thumbnail: item.snippet.thumbnails.maxres.url, // Fallback to high quality
  tags: item.snippet.tags || [],
  series: extractSeriesFromTitle(item.snippet.title), // Optional
  duration: parseDuration(item.contentDetails.duration),
  viewCount: item.statistics.viewCount,
};

// Validate before writing
const validationResult = await videoSchema.parseAsync(video);
fs.writeFileSync(`src/content/videos/${video.id}.json`, JSON.stringify(validationResult, null, 2));
```

### Component Data Access

```astro
---
// Example: Video listing component
import { getCollection } from 'astro:content';
const allVideos = await getCollection('videos');
const sorted = allVideos.sort((a, b) => 
  new Date(b.data.publishedAt) - new Date(a.data.publishedAt)
);
---

{sorted.map(video => (
  <article>
    <h2>{video.data.title}</h2>
    <p>{video.data.description}</p>
    <ul>
      {video.data.tags.map(tag => <li>{tag}</li>)}
    </ul>
  </article>
))}
```

---

## Scalability Considerations

**Current Design Supports**:
- 10-100+ videos (no performance issues with client-side search)
- 1-50+ community posts
- Unlimited tags (deduplicated at runtime)

**Future Scaling**:
- If 500+ videos: Consider pagination or categories filter
- If 100+ posts: Consider date-range filters
- If tags grow: Consider tag cloud or tag search
- If international: Add language field to posts

**Build Performance**:
- Video JSON collection: O(n) where n = number of videos
- Post markdown collection: O(m) where m = number of posts
- Client-side search: O(n) per keystroke (< 10ms for 100 videos on modern hardware)
- Total build time: Dominated by Tailwind CSS + image optimization (not data loading)
